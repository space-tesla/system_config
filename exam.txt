
Slip 1

Q.1) Take multiple files as Command Line Arguments and print their inode numbers and file types


#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>

int main(int argc, char *argv[]) {
    struct stat fileStat;

    for (int i = 1; i < argc; i++) {
        if (stat(argv[i], &fileStat) == 0) {
            printf("File: %s\n", argv[i]);
            printf("Inode number: %ld\n", fileStat.st_ino);

            if (S_ISDIR(fileStat.st_mode)) {
                printf("File Type: Directory\n");
            } else if (S_ISREG(fileStat.st_mode)) {
                printf("File Type: Regular File\n");
            } else if (S_ISLNK(fileStat.st_mode)) {
                printf("File Type: Symbolic Link\n");
            } else {
                printf("File Type: Other\n");
            }
        } else {
            perror("stat failed");
        }
        printf("---------------------------------\n");
    }

    return 0;
}

Output:
File: file1.txt
Inode number: 123456
File Type: Regular File
---------------------------------
File: directory1
Inode number: 654321
File Type: Directory
---------------------------------
File: link_to_file
Inode number: 112233
File Type: Symbolic Link
---------------------------------







Q.2) Write a C program to send SIGALRM signal by child process to parent process and parent process make a provision to catch the signal and display alarm is fired. (Use Kill, fork, signal and sleep system call)

#include <stdio.h>
#include <unistd.h>
#include <signal.h>

void alarmHandler(int sig) {
    printf("Alarm is fired!\n");
}

int main() {
    pid_t pid;

    signal(SIGALRM, alarmHandler);

    pid = fork();

    if (pid > 0) {
        sleep(2); 
        kill(pid, SIGALRM); 
        wait(NULL);
    } else if (pid == 0) {
        sleep(1); 
        _exit(0); 
    }

    return 0;
}

Output:
Alarm is fired!





Slip 2
Q.1) Write a C program to find file properties such as inode number, number of hard link, File permissions, File size, File access and modification time and so on of a given file using stat() system call.

#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <time.h>

int main() {
    struct stat fileStat;
    char *filename = "testfile.txt"; 

    if (stat(filename, &fileStat) == 0) {
        printf("Inode number: %ld\n", fileStat.st_ino);
        printf("Number of hard links: %ld\n", fileStat.st_nlink);
        printf("File size: %ld bytes\n", fileStat.st_size);
        printf("File permissions: %o\n", fileStat.st_mode & 0777);
        printf("Last accessed: %s", ctime(&fileStat.st_atime));
        printf("Last modified: %s", ctime(&fileStat.st_mtime));
        printf("Last status change: %s", ctime(&fileStat.st_ctime));
    } else {
        perror("stat failed");
    }

    return 0;
}


Output:
Inode number: 123456
Number of hard links: 1
File size: 1024 bytes
File permissions: 644
Last accessed: Thu Nov 11 10:30:00 2024
Last modified: Thu Nov 11 10:00:00 2024
Last status change: Thu Nov 11 09:00:00 2024






Q.2) Write a C program that catches the ctrl-c (SIGINT) signal for the first time and display the appropriate message and exits on pressing ctrl-c again.

#include <stdio.h>
#include <signal.h>
#include <stdlib.h>

int sigint_count = 0;

void sigint_handler(int sig) {
    sigint_count++;
    if (sigint_count == 1) {
        printf("Ctrl-C pressed! Press again to exit.\n");
    } else {
        printf("Exiting on second Ctrl-C press.\n");
        exit(0);
    }
}

int main() {
    signal(SIGINT, sigint_handler);

    while (1) {
        // Infinite loop to keep the program running
    }

    return 0;
}

Output:

Ctrl-C pressed! Press again to exit.

(After second Ctrl-C)
Exiting on second Ctrl-C press.





Slip 3

Q.1) Print the type of file and inode number where file name accepted through Command Line

#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>

int main(int argc, char *argv[]) {
    if (argc != 2) {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }

    struct stat fileStat;
    if (stat(argv[1], &fileStat) == 0) {
        printf("File: %s\n", argv[1]);
        printf("Inode number: %ld\n", fileStat.st_ino);

        if (S_ISDIR(fileStat.st_mode)) {
            printf("File Type: Directory\n");
        } else if (S_ISREG(fileStat.st_mode)) {
            printf("File Type: Regular File\n");
        } else if (S_ISLNK(fileStat.st_mode)) {
            printf("File Type: Symbolic Link\n");
        } else {
            printf("File Type: Other\n");
        }
    } else {
        perror("stat failed");
    }

    return 0;
}

Output:
File: testfile.txt
Inode number: 123456
File Type: Regular File




Q.2) Write a C program which creates a child process to run linux/unix command or any user defined program. The parent process sets the signal handler for death of child signal and Alarm signal. If a child process does not complete its execution in 5 seconds then parent process kills child process.

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>
#include <sys/wait.h>
#include <time.h>

pid_t child_pid;

void child_exit_handler(int sig) {
    printf("Child process terminated.\n");
    exit(0);
}

void alarm_handler(int sig) {
    printf("Child process did not complete in time. Killing child...\n");
    kill(child_pid, SIGKILL);
}

int main() {
    signal(SIGCHLD, child_exit_handler);
    signal(SIGALRM, alarm_handler);

    child_pid = fork();

    if (child_pid == 0) {
        // Child process runs the 'sleep' command for 10 seconds
        execlp("sleep", "sleep", "10", NULL);
        perror("execlp failed");
    } else if (child_pid > 0) {
        // Parent process sets an alarm for 5 seconds
        alarm(5);
        wait(NULL);  // Wait for the child to finish or be killed
    } else {
        perror("fork failed");
    }

    return 0;
}

(If the child process does not finish within 5 seconds)
Child process did not complete in time. Killing child...

(If the child finishes within 5 seconds)
Child process terminated.





Slip 4

Q.1) Write a C program to find whether a given file passed through command line arguments are present in current directory or not.

#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>

int main(int argc, char *argv[]) {
    struct stat fileStat;

    if (argc < 2) {
        printf("Usage: %s <filename1> <filename2> ...\n", argv[0]);
        return 1;
    }

    for (int i = 1; i < argc; i++) {
        if (stat(argv[i], &fileStat) == 0) {
            printf("File '%s' is present in the current directory.\n", argv[i]);
        } else {
            printf("File '%s' is NOT present in the current directory.\n", argv[i]);
        }
    }

    return 0;
}


Output:
File 'testfile.txt' is present in the current directory.
File 'image.jpg' is NOT present in the current directory.



Q.2) Write a C program which creates a child process and child process catches a signal SIGHUP, SIGINT and SIGQUIT. The Parent process sends a SIGHUP or SIGINT signal after every 3 seconds, at the end of 15 seconds parent sends SIGQUIT signal to child and child terminates by displaying message "My Papa has Killed me!!!â€.

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>
#include <sys/wait.h>

void signal_handler(int sig) {
    if (sig == SIGHUP) {
        printf("Child: Received SIGHUP\n");
    } else if (sig == SIGINT) {
        printf("Child: Received SIGINT\n");
    } else if (sig == SIGQUIT) {
        printf("Child: My Papa has Killed me!!!\n");
        exit(0);
    }
}

int main() {
    pid_t pid = fork();

    if (pid == 0) {
       
        signal(SIGHUP, signal_handler);
        signal(SIGINT, signal_handler);
        signal(SIGQUIT, signal_handler);

        while (1) {
           
            pause();
        }
    } else if (pid > 0) {
        // Parent process sends signals
        sleep(3);
        kill(pid, SIGHUP); 
        sleep(3);
        kill(pid, SIGINT); 
        sleep(6);
        kill(pid, SIGQUIT); 
        wait(NULL);
    } else {
        perror("fork failed");
    }

    return 0;
}


Output:
Child: Received SIGHUP
Child: Received SIGINT
Child: My Papa has Killed me!!!



Slip 5

Q.1) Read the current directory and display the name of the files, number of files in the current directory

#include <stdio.h>
#include <dirent.h>

int main() {
    struct dirent *entry;
    DIR *dp = opendir(".");

    if (dp == NULL) {
        perror("opendir");
        return 1;
    }

    int file_count = 0;
    printf("Files in the current directory:\n");
    while ((entry = readdir(dp)) != NULL) {
        if (entry->d_type == DT_REG) {
            printf("%s\n", entry->d_name);
            file_count++;
        }
    }

    closedir(dp);
    printf("Total number of files: %d\n", file_count);
    return 0;
}


Output:

Files in the current directory:
file1.txt
file2.c
myprogram.c
Total number of files: 3




Q.2) Write a C program to create an unnamed pipe. The child process will write the following three messages to the pipe, and the parent process will display them. Message1 = "Hello World" Message2 = "Hello SPPU" Message3 = "Linux is Funny"

#include <stdio.h>
#include <unistd.h>
#include <string.h>

int main() {
    int pipe_fd[2];
    pid_t pid;
    char buffer[100];

    if (pipe(pipe_fd) == -1) {
        perror("pipe");
        return 1;
    }

    pid = fork();

    if (pid == 0) {       
        close(pipe_fd[0]); 
        write(pipe_fd[1], "Hello World\n", strlen("Hello World\n"));
        write(pipe_fd[1], "Hello SPPU\n", strlen("Hello SPPU\n"));
        write(pipe_fd[1], "Linux is Funny\n", strlen("Linux is Funny\n"));
        close(pipe_fd[1]); 
    } else if (pid > 0) {       
        close(pipe_fd[1]);
        wait(NULL); 
        while (read(pipe_fd[0], buffer, sizeof(buffer)) > 0) {
            printf("%s", buffer);  
        }
        close(pipe_fd[0]);
    } else {
        perror("fork");
    }

    return 0;
}

Output:
Hello World
Hello SPPU
Linux is Funny



Slip 6

Q.1) Display all the files from the current directory which are created in a particular month

#include <stdio.h>
#include <dirent.h>
#include <sys/stat.h>
#include <time.h>

int main() {
    struct dirent *entry;
    struct stat fileStat;
    DIR *dp = opendir(".");
    char month[20];
    struct tm *timeinfo;
    int target_month;

    if (dp == NULL) {
        perror("opendir");
        return 1;
    }

    printf("Enter the month (1-12): ");
    scanf("%d", &target_month);

    printf("Files created in month %d:\n", target_month);
    while ((entry = readdir(dp)) != NULL) {
        if (stat(entry->d_name, &fileStat) == 0) {
            timeinfo = localtime(&fileStat.st_ctime);
            if (timeinfo->tm_mon + 1 == target_month) {
                printf("%s\n", entry->d_name);
            }
        }
    }

    closedir(dp);
    return 0;
}


Output:
Enter the month (1-12): 5
Files created in month 5:
file1.txt
image.jpg


Q.2) Write a C program to create n child processes. When all n child processes terminate, display the total cumulative time children spent in user and kernel mode.

#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>
#include <sys/resource.h>

int main() {
    int n;
    pid_t pid;
    struct rusage usage;
    long total_user_time = 0, total_sys_time = 0;

    printf("Enter number of child processes to create: ");
    scanf("%d", &n);

    for (int i = 0; i < n; i++) {
        pid = fork();
        if (pid == 0) {
           
            printf("Child %d started\n", i + 1);
            sleep(2); 
            exit(0);
        }
    }


    for (int i = 0; i < n; i++) {
        wait(NULL);
    }

 
    for (int i = 0; i < n; i++) {
        getrusage(RUSAGE_CHILDREN, &usage);
        total_user_time += usage.ru_utime.tv_sec;
        total_sys_time += usage.ru_stime.tv_sec;
    }

    printf("Total cumulative time spent by children:\n");
    printf("User mode time: %ld seconds\n", total_user_time);
    printf("Kernel mode time: %ld seconds\n", total_sys_time);

    return 0;
}


Output:
Enter number of child processes to create: 3
Child 1 started
Child 2 started
Child 3 started
Total cumulative time spent by children:
User mode time: 6 seconds
Kernel mode time: 3 seconds




Slip 7
Q.1) Write a C program that demonstrates redirection of standard output to a file

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>

int main() {
    int fd;

    // Open file for writing (creates file if it doesn't exist, truncates if it does)
    fd = open("output.txt", O_CREAT | O_WRONLY | O_TRUNC, 0644);
    if (fd == -1) {
        perror("Error opening file");
        return 1;
    }

    // Redirect standard output to the file
    dup2(fd, STDOUT_FILENO);
    close(fd);  // No longer need the file descriptor

    // Now any printf will be written to the file instead of the terminal
    printf("This output is redirected to the file output.txt\n");

    return 0;
}


Output (in the output.txt file):

This output is redirected to the file output.txt




Q.2) Implement the following unix/linux command (use fork, pipe and exec system call)
ls -l | wc -l

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

int main() {
    int pipefd[2];
    pid_t pid1, pid2;

    // Create pipe
    if (pipe(pipefd) == -1) {
        perror("pipe");
        return 1;
    }

    pid1 = fork();
    if (pid1 == -1) {
        perror("fork");
        return 1;
    }

    if (pid1 == 0) {
        // Child process 1 (ls -l)
        close(pipefd[0]);  // Close unused read end
        dup2(pipefd[1], STDOUT_FILENO);  // Redirect stdout to pipe
        close(pipefd[1]);  // Close the write end after duplicating

        execlp("ls", "ls", "-l", NULL);  // Execute ls -l
        perror("execlp ls");
        return 1;
    } else {
        pid2 = fork();
        if (pid2 == -1) {
            perror("fork");
            return 1;
        }

        if (pid2 == 0) {
            // Child process 2 (wc -l)
            close(pipefd[1]);  // Close unused write end
            dup2(pipefd[0], STDIN_FILENO);  // Redirect stdin from pipe
            close(pipefd[0]);  // Close the read end after duplicating

            execlp("wc", "wc", "-l", NULL);  // Execute wc -l
            perror("execlp wc");
            return 1;
        } else {
            close(pipefd[0]);  // Close pipe ends in parent process
            close(pipefd[1]);

            // Wait for both children to finish
            wait(NULL);
            wait(NULL);
        }
    }

    return 0;
}

Output (from wc -l in the terminal, showing the number of lines in the directory):

<Number of lines in the directory>



Slip 8

Q.1) Write a C program that redirects standard output to a file output.txt. (use of dup and open system call)

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>

int main() {
    int fd = open("output.txt", O_CREAT | O_WRONLY | O_TRUNC, 0644);
    dup2(fd, STDOUT_FILENO);
    close(fd);
    printf("This output is redirected to the file output.txt\n");
    return 0;
}


Output (in the output.txt file):

This output is redirected to the file output.txt


Q.2) Implement the following unix/linux command (use fork, pipe and exec system call) ls -l | wc -l

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

int main() {
    int pipefd[2];
    pipe(pipefd);
    pid_t pid1 = fork();

    if (pid1 == 0) {
        close(pipefd[0]);
        dup2(pipefd[1], STDOUT_FILENO);
        close(pipefd[1]);
        execlp("ls", "ls", "-l", NULL);
        exit(1);
    }

    pid_t pid2 = fork();

    if (pid2 == 0) {
        close(pipefd[1]);
        dup2(pipefd[0], STDIN_FILENO);
        close(pipefd[0]);
        execlp("wc", "wc", "-l", NULL);
        exit(1);
    }

    close(pipefd[0]);
    close(pipefd[1]);
    wait(NULL);
    wait(NULL);
    return 0;
}


Output (from wc -l in the terminal, showing the number of lines in the directory):

<Number of lines in the directory>





Slip 9

Q.1) Generate parent process to write unnamed pipe and will read from it

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main() {
    int pipefd[2];
    pipe(pipefd);

    if (fork() == 0) {
        close(pipefd[0]);
        write(pipefd[1], "Hello from parent process", 26);
        close(pipefd[1]);
        exit(0);
    } else {
        char buffer[30];
        close(pipefd[1]);
        read(pipefd[0], buffer, sizeof(buffer));
        printf("%s\n", buffer);
        close(pipefd[0]);
    }

    return 0;
}

Output:
Hello from parent process


Q.2) Write a C program to identify the type (Directory, character device, Block device, Regular file, FIFO or pipe, symbolic link or socket) of given file using stat() system call

#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>

int main(int argc, char *argv[]) {
    struct stat fileStat;
    
    if (argc != 2) {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }
    
    if (stat(argv[1], &fileStat) < 0) {
        perror("stat");
        return 1;
    }
    
    if (S_ISREG(fileStat.st_mode))
        printf("Regular file\n");
    else if (S_ISDIR(fileStat.st_mode))
        printf("Directory\n");
    else if (S_ISCHR(fileStat.st_mode))
        printf("Character device\n");
    else if (S_ISBLK(fileStat.st_mode))
        printf("Block device\n");
    else if (S_ISFIFO(fileStat.st_mode))
        printf("FIFO or pipe\n");
    else if (S_ISLNK(fileStat.st_mode))
        printf("Symbolic link\n");
    else if (S_ISSOCK(fileStat.st_mode))
        printf("Socket\n");
    
    return 0;
}

Output:
Regular file


Slip 10

Q.1) Write a program that illustrates how to execute two commands concurrently with a pipe.

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

int main() {
    int pipefd[2];
    pipe(pipefd);
    pid_t pid1 = fork();

    if (pid1 == 0) {
        close(pipefd[0]);
        dup2(pipefd[1], STDOUT_FILENO);
        close(pipefd[1]);
        execlp("ls", "ls", NULL);
        exit(1);
    }

    pid_t pid2 = fork();

    if (pid2 == 0) {
        close(pipefd[1]);
        dup2(pipefd[0], STDIN_FILENO);
        close(pipefd[0]);
        execlp("wc", "wc", "-l", NULL);
        exit(1);
    }

    close(pipefd[0]);
    close(pipefd[1]);
    wait(NULL);
    wait(NULL);
    return 0;
}


Output:

<Number of files and directories in the current directory>


Q.2) Generate parent process to write unnamed pipe and will write into it. Also generate child process which will read from pipe.
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

int main() {
    int pipefd[2];
    pipe(pipefd);
    pid_t pid = fork();

    if (pid > 0) {
        close(pipefd[0]);
        char msg[] = "Message from parent process";
        write(pipefd[1], msg, strlen(msg) + 1);
        close(pipefd[1]);
        wait(NULL);
    } else {
        close(pipefd[1]);
        char buffer[100];
        read(pipefd[0], buffer, sizeof(buffer));
        printf("Read from pipe: %s\n", buffer);
        close(pipefd[0]);
        exit(0);
    }
    return 0;
}


Output:
Read from pipe: Message from parent process



Slip 11

Q.1) Write a C program to get and set the resource limits such as files, memory associated with a process

#include <stdio.h>
#include <stdlib.h>
#include <sys/resource.h>

int main() {
    struct rlimit limit;

    getrlimit(RLIMIT_NOFILE, &limit);
    printf("Current file limit: %ld\n", limit.rlim_cur);
    printf("Maximum file limit: %ld\n", limit.rlim_max);

    limit.rlim_cur = 2048;
    setrlimit(RLIMIT_NOFILE, &limit);

    getrlimit(RLIMIT_NOFILE, &limit);
    printf("Updated file limit: %ld\n", limit.rlim_cur);

    getrlimit(RLIMIT_AS, &limit);
    printf("Current memory limit: %ld\n", limit.rlim_cur);
    printf("Maximum memory limit: %ld\n", limit.rlim_max);

    limit.rlim_cur = 512 * 1024 * 1024;
    setrlimit(RLIMIT_AS, &limit);

    getrlimit(RLIMIT_AS, &limit);
    printf("Updated memory limit: %ld\n", limit.rlim_cur);

    return 0;
}

Output:
Current file limit: <current limit>
Maximum file limit: <maximum limit>
Updated file limit: 2048
Current memory limit: <current memory limit>
Maximum memory limit: <maximum memory limit>
Updated memory limit: 536870912


Q.2) Write a C program that redirects standard output to a file output.txt. (use of dup and open system call)
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>

int main() {
    int fd = open("output.txt", O_CREAT | O_WRONLY | O_TRUNC, 0644);
    dup2(fd, STDOUT_FILENO);
    close(fd);
    printf("This output is redirected to the file output.txt\n");
    return 0;
}


Output (in the output.txt file):

This output is redirected to the file output.txt




Slip 12

Q.1) Write a C program that prints the exit status of a terminated child process

#include <stdio.h>
#include <stdlib.h>
#include <sys/wait.h>
#include <unistd.h>

int main() {
    pid_t pid = fork();

    if (pid == 0) {
        exit(5); 
    } else {
        int status;
        wait(&status);
        if (WIFEXITED(status)) {
            printf("Child exited with status: %d\n", WEXITSTATUS(status));
        }
    }
    return 0;
}


Slip 12

Q.1) Write a C program that prints the exit status of a terminated child process

#include <stdio.h>
#include <stdlib.h>
#include <sys/wait.h>
#include <unistd.h>

int main() {
    pid_t pid = fork();

    if (pid == 0) {
        exit(5); 
    } else {
        int status;
        wait(&status);
        if (WIFEXITED(status)) {
            printf("Child exited with status: %d\n", WEXITSTATUS(status));
        }
    }
    return 0;
}

Output:
Child exited with status: 5


Q.2) Write a C program which receives file names as command line arguments and displays those filenames in ascending order according to their sizes

#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>

int compare(const void *a, const void *b) {
    struct stat statA, statB;
    stat(*(char **)a, &statA);
    stat(*(char **)b, &statB);
    return statA.st_size - statB.st_size;
}

int main(int argc, char *argv[]) {
    if (argc < 2) {
        printf("Usage: %s <file1> <file2> ...\n", argv[0]);
        return 1;
    }

    qsort(argv + 1, argc - 1, sizeof(char *), compare);

    for (int i = 1; i < argc; i++) {
        struct stat fileStat;
        stat(argv[i], &fileStat);
        printf("%s: %ld bytes\n", argv[i], fileStat.st_size);
    }

    return 0;
}


Output:

a.txt: 120 bytes
b.txt: 200 bytes
c.txt: 350 bytes



Slip 13
Q.1) Write a C program that illustrates suspending and resuming processes using signals

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>

void suspend_handler(int sig) {
    printf("Suspended. Press Ctrl+Z to resume.\n");
    pause(); // Suspends the process until a signal is received
}

int main() {
    signal(SIGTSTP, suspend_handler); // Catch Ctrl+Z (SIGTSTP)
    
    while(1) {
        printf("Process running... Press Ctrl+Z to suspend.\n");
        sleep(1);  // Simulating some work
    }
    
    return 0;
}


Output:

Process running... Press Ctrl+Z to suspend.
Process running... Press Ctrl+Z to suspend.
Suspended. Press Ctrl+Z to resume.


Q.2) Write a C program that takes a string as an argument and returns all the files that begin with that name in the current directory

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <dirent.h>

int main(int argc, char *argv[]) {
    if (argc != 2) {
        printf("Usage: %s <prefix>\n", argv[0]);
        return 1;
    }

    DIR *dir;
    struct dirent *entry;
    char *prefix = argv[1];

    dir = opendir(".");
    if (dir == NULL) {
        perror("opendir");
        return 1;
    }

    printf("Files starting with '%s':\n", prefix);
    while ((entry = readdir(dir)) != NULL) {
        if (strncmp(entry->d_name, prefix, strlen(prefix)) == 0) {
            printf("%s\n", entry->d_name);
        }
    }

    closedir(dir);
    return 0;
}

Output (assuming files foo.txt, foo_bar.txt, and bar.txt exist in the current directory):

Files starting with 'foo':
foo.txt
foo_bar.txt



Slip 14

Q.1) Display all the files from the current directory whose size is greater than n bytes, where n is accepted from the user

#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <dirent.h>
#include <string.h>

int main() {
    char dir_path[] = ".";  // Current directory
    DIR *dir;
    struct dirent *entry;
    struct stat file_stat;
    long n;

    printf("Enter the size in bytes: ");
    scanf("%ld", &n);

    dir = opendir(dir_path);
    if (dir == NULL) {
        perror("opendir");
        return 1;
    }

    printf("Files greater than %ld bytes:\n", n);
    while ((entry = readdir(dir)) != NULL) {
        if (stat(entry->d_name, &file_stat) == 0) {
            if (file_stat.st_size > n) {
                printf("%s\n", entry->d_name);
            }
        }
    }

    closedir(dir);
    return 0;
}

Output (assuming files file1.txt, file2.txt, and file3.txt exist with varying sizes):

Enter the size in bytes: 100
Files greater than 100 bytes:
file2.txt
file3.txt



Q.2) Write a C program to find file properties such as inode number, number of hard links, file permissions, file size, file access and modification time, and so on of a given file using the stat() system call

#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <time.h>

int main() {
    struct stat fileStat;
    char filename[100];

    printf("Enter the filename: ");
    scanf("%s", filename);

    if (stat(filename, &fileStat) == -1) {
        perror("stat");
        return 1;
    }

    printf("File: %s\n", filename);
    printf("Inode: %ld\n", fileStat.st_ino);
    printf("Number of hard links: %ld\n", fileStat.st_nlink);
    printf("File size: %ld bytes\n", fileStat.st_size);
    printf("File permissions: %o\n", fileStat.st_mode & 0777);
    printf("Last access time: %s", ctime(&fileStat.st_atime));
    printf("Last modification time: %s", ctime(&fileStat.st_mtime));
    printf("Last change time: %s", ctime(&fileStat.st_ctime));

    return 0;
}


Output:
Enter the filename: example.txt
File: example.txt
Inode: 123456
Number of hard links: 1
File size: 1234 bytes
File permissions: 644
Last access time: Fri Nov 11 12:34:56 2024
Last modification time: Fri Nov 11 12:34:56 2024
Last change time: Fri Nov 11 12:34:56 2024


Slip 15

Q.1) Display all the files from the current directory whose size is greater than n Bytes, where n is accepted from the user

#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <dirent.h>
#include <string.h>

int main() {
    DIR *dir;
    struct dirent *entry;
    struct stat fileStat;
    char *directory = "."; // Current directory
    long n;

    printf("Enter the size (in bytes): ");
    scanf("%ld", &n);

    dir = opendir(directory);
    if (dir == NULL) {
        perror("opendir");
        return 1;
    }

    printf("Files larger than %ld bytes:\n", n);
    while ((entry = readdir(dir)) != NULL) {
        if (stat(entry->d_name, &fileStat) == 0) {
            if (fileStat.st_size > n) {
                printf("%s\n", entry->d_name);
            }
        }
    }

    closedir(dir);
    return 0;
}

Output:
Enter the size (in bytes): 1000
Files larger than 1000 bytes:
largefile.txt
anotherfile.dat


Q.2) Write a C program which creates a child process to run a Linux/Unix command or any user-defined program. The parent process sets the signal handler for the death of the child signal and alarm signal. If a child process does not complete its execution in 5 seconds, then the parent process kills the child process.

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>
#include <sys/wait.h>
#include <time.h>

void childHandler(int sig) {
    printf("Child process terminated\n");
    exit(0);
}

void alarmHandler(int sig) {
    printf("Child process took too long. Killing it...\n");
    exit(0);
}

int main() {
    pid_t pid;
    struct sigaction sa;
    
    signal(SIGALRM, alarmHandler); // Set alarm signal handler
    signal(SIGCHLD, childHandler); // Set child termination signal handler

    pid = fork();

    if (pid == 0) {
        // Child process
        sleep(10);  // Simulating a command or process taking longer than expected
        printf("Child process completed\n");
        exit(0);
    } 
    else if (pid > 0) {
        // Parent process
        alarm(5);  // Set an alarm for 5 seconds
        wait(NULL); // Wait for child process to finish
    } 
    else {
        perror("Fork failed");
        return 1;
    }

    return 0;
}

Output:
Child process took too long. Killing it...

slip 16
//Q.1)Display all the files from the current directory which are created in a particular month.
#include <stdio.h>
#include <stdlib.h>

int main() {
    char month[10];
    printf("Enter the month (e.g., Jan, Feb, Mar): ");
    scanf("%s", month);

    char command[50];
    sprintf(command, "ls -l --time-style=+%%b | grep ' %s '", month);
    system(command);

    return 0;
}








/*Enter the month (e.g., Jan, Feb, Mar): Jan
-rw-r--r-- 1 user user 1024 Jan 15 10:00 example.txt
-rw-r--r-- 1 user user 2048 Jan 20 12:30 data.csv
*/
/*Write a C program that creates a child process to catch SIGHUP, SIGINT, and SIGQUIT signals. The parent process sends a SIGHUP or SIGINT signal every 3 seconds. After 30 seconds, the parent sends a SIGQUIT signal to the child, causing it to terminate with the message "My DADDY has Killed me!!!".*/
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>

void handle_sighup(int sig) { printf("Received SIGHUP\n"); }
void handle_sigint(int sig) { printf("Received SIGINT\n"); }
void handle_sigquit(int sig) { printf("My DADDY has Killed me!!!\n"); exit(0); }

int main() {
    pid_t pid = fork();

    if (pid == 0) {
        signal(SIGHUP, handle_sighup);
        signal(SIGINT, handle_sigint);
        signal(SIGQUIT, handle_sigquit);
        while (1) pause();
    } else {
        for (int i = 0; i < 10; i++) {
            sleep(3);
            if (i % 2 == 0) kill(pid, SIGHUP);
            else kill(pid, SIGINT);
        }
        kill(pid, SIGQUIT);
    }

    return 0;
}

slip 17
/*Q.1.Read the current directory and display the names of the files and the number of files in the current directory.*/
#include <stdio.h>
#include <dirent.h>

int main() {
    DIR *d;
    struct dirent *dir;
    int count = 0;

    d = opendir(".");
    if (d) {
        printf("Files in current directory:\n");
        while ((dir = readdir(d)) != NULL) {
            if (dir->d_type == DT_REG) {
                printf("%s\n", dir->d_name);
                count++;
            }
        }
        closedir(d);
        printf("Total number of files: %d\n", count);
    }

    return 0;
}





/*Files in current directory:
file1.txt
file2.c
image.png
Total number of files: 3
*/
/*Write a C program to implement the following Unix/Linux command using fork, pipe, and exec system calls. Block the Ctrl-C and Ctrl-\ signals during execution.*/
/*Command to implement: ls -l | wc -l*/
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>
#include <sys/wait.h>

void block_signals() {
    signal(SIGINT, SIG_IGN);
    signal(SIGQUIT, SIG_IGN);
}

int main() {
    int pipe_fd[2];
    pid_t pid;

    block_signals();
    pipe(pipe_fd);

    pid = fork();
    if (pid == 0) {
        close(pipe_fd[0]);
        dup2(pipe_fd[1], STDOUT_FILENO);
        execlp("ls", "ls", "-l", NULL);
        exit(0);
    } else {
        pid = fork();
        if (pid == 0) {
            close(pipe_fd[1]);
            dup2(pipe_fd[0], STDIN_FILENO);
            execlp("wc", "wc", "-l", NULL);
            exit(0);
        }
    }

    close(pipe_fd[0]);
    close(pipe_fd[1]);
    wait(NULL);
    wait(NULL);

    return 0;
}


/*10
*/

slip 18
/* Write a C program to find whether a given file is present in the current directory or not.*/
#include <stdio.h>
#include <dirent.h>
#include <string.h>

int main() {
    char filename[100];
    int found = 0;
    DIR *d;
    struct dirent *dir;

    printf("Enter the filename to search: ");
    scanf("%s", filename);

    d = opendir(".");
    if (d) {
        while ((dir = readdir(d)) != NULL) {
            if (strcmp(dir->d_name, filename) == 0) {
                found = 1;
                break;
            }
        }
        closedir(d);
    }

    if (found) {
        printf("File '%s' found in the current directory.\n", filename);
    } else {
        printf("File '%s' not found in the current directory.\n", filename);
    }

    return 0;
}



/*Enter the filename to search: example.txt
File 'example.txt' found in the current directory.
*/

/*Write a C program to create an unnamed pipe. The child process will write the following three messages to the pipe, and the parent process will display them.*/
/*Messages:

Message1 = "Hello World"
Message2 = "Hello SPPU"
Message3 = "Linux is Funny"*/
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main() {
    int pipe_fd[2];
    pid_t pid;
    char message[100];

    pipe(pipe_fd);
    pid = fork();

    if (pid == 0) {
        close(pipe_fd[0]);
        write(pipe_fd[1], "Hello World\n", 12);
        write(pipe_fd[1], "Hello SPPU\n", 11);
        write(pipe_fd[1], "Linux is Funny\n", 15);
        close(pipe_fd[1]);
        exit(0);
    } else {
        close(pipe_fd[1]);
        while (read(pipe_fd[0], message, sizeof(message)) > 0) {
            printf("%s", message);
        }
        close(pipe_fd[0]);
    }

    return 0;
}






/*Hello World
Hello SPPU
Linux is Funny
*/
slip 19

/*Take multiple files as command-line arguments and print their file type and inode number.*/
#include <stdio.h>
#include <sys/stat.h>

int main(int argc, char *argv[]) {
    struct stat fileStat;
    for (int i = 1; i < argc; i++) {
        if (stat(argv[i], &fileStat) == 0) {
            printf("File: %s\n", argv[i]);
            printf("Inode: %ld\n", fileStat.st_ino);
            if (S_ISREG(fileStat.st_mode))
                printf("Type: Regular File\n\n");
            else if (S_ISDIR(fileStat.st_mode))
                printf("Type: Directory\n\n");
            else
                printf("Type: Other\n\n");
        } else {
            printf("Cannot access %s\n\n", argv[i]);
        }
    }
    return 0;
}


/*$ ./a.out file1.txt directory1 file2.txt
File: file1.txt
Inode: 1234567
Type: Regular File

File: directory1
Inode: 1234589
Type: Directory

File: file2.txt
Inode: 1234590
Type: Regular File
*/














/*Received SIGHUP
Received SIGINT
Received SIGHUP
Received SIGINT
Received SIGHUP
Received SIGINT
Received SIGHUP
Received SIGINT
Received SIGHUP
Received SIGINT
My DADDY has Killed me!!!
*/

/* Implement the following Unix/Linux command using fork, pipe, and exec system calls.

Command to implement: ls -l | wc -l*/
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

int main() {
    int pipe_fd[2];
    pid_t pid;

    pipe(pipe_fd);

    pid = fork();
    if (pid == 0) {
        close(pipe_fd[0]);
        dup2(pipe_fd[1], STDOUT_FILENO);
        execlp("ls", "ls", "-l", NULL);
        exit(0);
    } else {
        pid = fork();
        if (pid == 0) {
            close(pipe_fd[1]);
            dup2(pipe_fd[0], STDIN_FILENO);
            execlp("wc", "wc", "-l", NULL);
            exit(0);
        }
    }

    close(pipe_fd[0]);
    close(pipe_fd[1]);
    wait(NULL);
    wait(NULL);

    return 0;
}

/*10
*/

slip 20
/*Write a C program that illustrates suspending and resuming processes using signals.*/
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

void suspend_handler(int sig) {
    printf("Process suspended. Waiting for SIGCONT to resume...\n");
    pause();
}

void resume_handler(int sig) {
    printf("Process resumed.\n");
}

int main() {
    signal(SIGTSTP, suspend_handler);
    signal(SIGCONT, resume_handler);

    while (1) {
        printf("Running... Press Ctrl+Z to suspend.\n");
        sleep(2);
    }

    return 0;
}

/*Running... Press Ctrl+Z to suspend.
Process suspended. Waiting for SIGCONT to resume...
Process resumed.
Running... Press Ctrl+Z to suspend.
*/
/*Write a C program to identify the type (Directory, character device, block device, regular file, FIFO or pipe, symbolic link, or socket) of a given file using the stat() system call.*/
#include <stdio.h>
#include <sys/stat.h>

int main() {
    char filename[100];
    struct stat fileStat;

    printf("Enter the filename: ");
    scanf("%s", filename);

    if (stat(filename, &fileStat) == 0) {
        printf("File: %s\n", filename);
        if (S_ISREG(fileStat.st_mode)) printf("Type: Regular File\n");
        else if (S_ISDIR(fileStat.st_mode)) printf("Type: Directory\n");
        else if (S_ISCHR(fileStat.st_mode)) printf("Type: Character Device\n");
        else if (S_ISBLK(fileStat.st_mode)) printf("Type: Block Device\n");
        else if (S_ISFIFO(fileStat.st_mode)) printf("Type: FIFO or Pipe\n");
        else if (S_ISLNK(fileStat.st_mode)) printf("Type: Symbolic Link\n");
        else if (S_ISSOCK(fileStat.st_mode)) printf("Type: Socket\n");
        else printf("Type: Unknown\n");
    } else {
        printf("Cannot access file: %s\n", filename);
    }

    return 0;
}


/*Enter the filename: example.txt
File: example.txt
Type: Regular File
*/

slip 21

/*Write a C program to identify the type (Directory, character device, block device, regular file, FIFO or pipe, symbolic link, or socket) of a given file using the stat() system call.*/
#include <stdio.h>
#include <sys/stat.h>

int main() {
    char filename[100];
    struct stat fileStat;

    printf("Enter the filename: ");
    scanf("%s", filename);

    if (stat(filename, &fileStat) == 0) {
        printf("File: %s\n", filename);
        if (S_ISREG(fileStat.st_mode)) printf("Type: Regular File\n");
        else if (S_ISDIR(fileStat.st_mode)) printf("Type: Directory\n");
        else if (S_ISCHR(fileStat.st_mode)) printf("Type: Character Device\n");
        else if (S_ISBLK(fileStat.st_mode)) printf("Type: Block Device\n");
        else if (S_ISFIFO(fileStat.st_mode)) printf("Type: FIFO or Pipe\n");
        else if (S_ISLNK(fileStat.st_mode)) printf("Type: Symbolic Link\n");
        else if (S_ISSOCK(fileStat.st_mode)) printf("Type: Socket\n");
        else printf("Type: Unknown\n");
    } else {
        printf("Cannot access file: %s\n", filename);
    }

    return 0;
}


/*Enter the filename: example.txt
File: example.txt
Type: Regular File
*/
/*Write a C program that receives file names as command-line arguments and displays those filenames in ascending order according to their sizes.

Example Usage: ./a.out a.txt b.txt c.txt*/
#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <string.h>

typedef struct {
    char filename[100];
    off_t size;
} FileInfo;

int compare(const void *a, const void *b) {
    return ((FileInfo *)a)->size - ((FileInfo *)b)->size;
}

int main(int argc, char *argv[]) {
    if (argc < 2) {
        printf("Usage: %s <file1> <file2> ...\n", argv[0]);
        return 1;
    }

    FileInfo files[argc - 1];
    struct stat fileStat;

    for (int i = 1; i < argc; i++) {
        if (stat(argv[i], &fileStat) == 0) {
            strcpy(files[i - 1].filename, argv[i]);
            files[i - 1].size = fileStat.st_size;
        } else {
            printf("Cannot access %s\n", argv[i]);
            return 1;
        }
    }

    qsort(files, argc - 1, sizeof(FileInfo), compare);

    printf("Files in ascending order by size:\n");
    for (int i = 0; i < argc - 1; i++) {
        printf("%s (%ld bytes)\n", files[i].filename, files[i].size);
    }

    return 0;
}

/*$ ./a.out file1.txt file2.txt file3.txt
Files in ascending order by size:
file3.txt (500 bytes)
file1.txt (1024 bytes)
file2.txt (2048 bytes)
*/

slip 22
/*Write a C program that demonstrates redirection of standard output to a file.*/
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>

int main() {
    int file = open("output.txt", O_WRONLY | O_CREAT | O_TRUNC, 0644);
    if (file < 0) {
        perror("Failed to open file");
        return 1;
    }

    dup2(file, STDOUT_FILENO);
    close(file);

    printf("This message will be written to output.txt instead of standard output.\n");

    return 0;
}

/*The text "This message will be written to output.txt instead of standard output." will be saved in the file output.txt.*/

/*Write a C program to implement the following Unix/Linux command using fork, pipe, and exec system calls. Block the Ctrl-C and Ctrl-\ signals during execution.

Command to implement: ls -l | wc -l*/
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>
#include <sys/wait.h>

void block_signals() {
    signal(SIGINT, SIG_IGN);
    signal(SIGQUIT, SIG_IGN);
}

int main() {
    int pipe_fd[2];
    pid_t pid;

    block_signals();
    pipe(pipe_fd);

    pid = fork();
    if (pid == 0) {
        close(pipe_fd[0]);
        dup2(pipe_fd[1], STDOUT_FILENO);
        execlp("ls", "ls", "-l", NULL);
        exit(0);
    } else {
        pid = fork();
        if (pid == 0) {
            close(pipe_fd[1]);
            dup2(pipe_fd[0], STDIN_FILENO);
            execlp("wc", "wc", "-l", NULL);
            exit(0);
        }
    }

    close(pipe_fd[0]);
    close(pipe_fd[1]);
    wait(NULL);
    wait(NULL);

    return 0;
}

/*10
*/

slip 23
Write a C program to find whether a given file is present in the current directory or not.
#include <stdio.h>
#include <dirent.h>
#include <string.h>

int main() {
    char filename[100];
    int found = 0;
    DIR *d;
    struct dirent *dir;

    printf("Enter the filename to search: ");
    scanf("%s", filename);

    d = opendir(".");
    if (d) {
        while ((dir = readdir(d)) != NULL) {
            if (strcmp(dir->d_name, filename) == 0) {
                found = 1;
                break;
            }
        }
        closedir(d);
    }

    if (found) {
        printf("File '%s' found in the current directory.\n", filename);
    } else {
        printf("File '%s' not found in the current directory.\n", filename);
    }

    return 0;
}


/*Enter the filename to search: example.txt
File 'example.txt' found in the current directory.
*/

/*Write a C program to identify the type (Directory, character device, Block device, Regular file, FIFO or pipe, symbolic link or socket) of a given file using the stat() system call.*/
#include <stdio.h>
#include <sys/stat.h>

int main() {
    char filename[100];
    struct stat fileStat;

    printf("Enter the filename: ");
    scanf("%s", filename);

    if (stat(filename, &fileStat) == 0) {
        printf("File: %s\n", filename);
        if (S_ISREG(fileStat.st_mode)) printf("Type: Regular File\n");
        else if (S_ISDIR(fileStat.st_mode)) printf("Type: Directory\n");
        else if (S_ISCHR(fileStat.st_mode)) printf("Type: Character Device\n");
        else if (S_ISBLK(fileStat.st_mode)) printf("Type: Block Device\n");
        else if (S_ISFIFO(fileStat.st_mode)) printf("Type: FIFO or Pipe\n");
        else if (S_ISLNK(fileStat.st_mode)) printf("Type: Symbolic Link\n");
        else if (S_ISSOCK(fileStat.st_mode)) printf("Type: Socket\n");
        else printf("Type: Unknown\n");
    } else {
        printf("Cannot access file: %s\n", filename);
    }

    return 0;
}

/*Enter the filename: example.txt
File: example.txt
Type: Regular File
*/

slip 24
/*Print the type of file and inode number where the filename is accepted through the command line.*/
#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <string.h>

int main(int argc, char *argv[]) {
    if (argc != 2) {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }

    struct stat fileStat;
    if (stat(argv[1], &fileStat) == 0) {
        printf("File: %s\n", argv[1]);
        printf("Inode: %ld\n", fileStat.st_ino);
        
        if (S_ISREG(fileStat.st_mode)) printf("Type: Regular File\n");
        else if (S_ISDIR(fileStat.st_mode)) printf("Type: Directory\n");
        else if (S_ISCHR(fileStat.st_mode)) printf("Type: Character Device\n");
        else if (S_ISBLK(fileStat.st_mode)) printf("Type: Block Device\n");
        else if (S_ISFIFO(fileStat.st_mode)) printf("Type: FIFO or Pipe\n");
        else if (S_ISLNK(fileStat.st_mode)) printf("Type: Symbolic Link\n");
        else if (S_ISSOCK(fileStat.st_mode)) printf("Type: Socket\n");
        else printf("Type: Unknown\n");
    } else {
        printf("Cannot access file: %s\n", argv[1]);
    }

    return 0;
}


/*$ ./a.out example.txt
File: example.txt
Inode: 1234567
Type: Regular File
*/

/*Write a C program which creates a child process to run a Linux/Unix command or any user-defined program. The parent process sets the signal handler for the death of the child signal and alarm signal. If a child process does not complete its execution in 5 seconds, the parent process kills the child process.*/
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>
#include <sys/wait.h>

pid_t child_pid;

void child_exit_handler(int sig) {
    printf("Child process has completed.\n");
}

void alarm_handler(int sig) {
    printf("Child process took too long. Killing it...\n");
    kill(child_pid, SIGKILL);
}

int main() {
    signal(SIGCHLD, child_exit_handler);  // Signal handler for child death
    signal(SIGALRM, alarm_handler);       // Signal handler for alarm

    child_pid = fork();

    if (child_pid == 0) {
        // Child process
        printf("Child process running...\n");
        execlp("sleep", "sleep", "10", NULL);  // Example: Run a long command
    } else {
        // Parent process
        printf("Parent process waiting for child to finish...\n");
        alarm(5);  // Set an alarm after 5 seconds
        wait(NULL);  // Wait for the child to finish
    }

    return 0;
}

/*Parent process waiting for child to finish...
Child process running...
Child process took too long. Killing it...
*/

slip 25

/*Write a C program that demonstrates redirection of standard output to a file.*/
#include <stdio.h>
#include <stdlib.h>

int main() {
    FILE *file = freopen("output.txt", "w", stdout);
    if (file == NULL) {
        perror("Failed to redirect stdout");
        return 1;
    }

    printf("This message will be written to output.txt instead of standard output.\n");

    fclose(file);
    return 0;
}

/*The text "This message will be written to output.txt instead of standard output." will be saved in the file output.txt.*/

/*Write a C program that redirects standard output to a file output.txt using the dup and open system calls.*/
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>

int main() {
    int file = open("output.txt", O_WRONLY | O_CREAT | O_TRUNC, 0644);
    if (file < 0) {
        perror("Failed to open file");
        return 1;
    }

    dup2(file, STDOUT_FILENO);
    close(file);

    printf("This message will be written to output.txt instead of standard output.\n");

    return 0;
}


/*The text "This message will be written to output.txt instead of standard output." will be saved in the file output.txt.*/
